/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultShader = __webpack_require__(/*! ./default.wgsl */ "./src/default.wgsl");
// import defaultShader from "default.wgsl";
window.onload = () => __awaiter(void 0, void 0, void 0, function* () {
    console.log(defaultShader);
    const canvas = document.querySelector("canvas");
    if (!canvas) {
        console.error("No canvas");
        return;
    }
    const context = canvas.getContext("webgpu");
    if (!context) {
        console.error("No webgpu context");
        return;
    }
    const adapter = yield window.navigator.gpu.requestAdapter();
    if (!adapter) {
        console.error("Could not get WebGPU adapter");
        return;
    }
    console.log(adapter);
    console.log([...adapter.features]);
    const gpu = yield adapter.requestDevice();
    if (!gpu) {
        console.error("Could not get GPU");
        return;
    }
    // TODO(jan): According to the spec, rgba8unorm-srgb should be supported by all devices.
    // But apparently it is not.
    const configuration = {
        device: gpu,
        format: "bgra8unorm"
    };
    context.configure(configuration);
    const queue = gpu.queue;
    console.log(queue);
    // TODO(jan): Determine from Vertex data size.
    const vertexBufferSize = 1024;
    let stagingBuffer;
    {
        const descriptor = {
            size: vertexBufferSize,
            usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
        };
        stagingBuffer = gpu.createBuffer(descriptor);
        // NOTE(jan): This will reject if it fails, so no need to check.
        yield stagingBuffer.mapAsync(GPUMapMode.WRITE);
        const memory = stagingBuffer.getMappedRange();
        console.log("memory: ", memory);
        const vertices = new Float32Array(memory);
        console.log("vertices: ", vertices);
        let i = 0;
        vertices[i++] = 0;
        vertices[i++] = 1;
        vertices[i++] = 0;
        vertices[i++] = 1;
        vertices[i++] = 1;
        vertices[i++] = -1;
        vertices[i++] = 0;
        vertices[i++] = 1;
        vertices[i++] = -1;
        vertices[i++] = -1;
        vertices[i++] = 0;
        vertices[i++] = 1;
        stagingBuffer.unmap();
    }
    let vertexBuffer;
    {
        const descriptor = {
            size: vertexBufferSize,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        };
        vertexBuffer = gpu.createBuffer(descriptor);
    }
    {
        let encoder = gpu.createCommandEncoder();
        encoder.copyBufferToBuffer(stagingBuffer, 0, vertexBuffer, 0, vertexBufferSize);
        let cmds = encoder.finish();
        queue.submit([cmds]);
    }
    let module;
    {
        const descriptor = {
            code: defaultShader,
        };
        module = gpu.createShaderModule(descriptor);
        const info = yield module.compilationInfo();
        for (const message of info.messages) {
            if (message.type == "error")
                return;
        }
    }
    let pipeline;
    {
        const attribute = {
            format: "float32x4",
            offset: 0,
            // TODO(jan): How to determine this?
            shaderLocation: 0
        };
        const attributes = [attribute];
        const vertexLayout = {
            // TODO(jan): Compute this?
            arrayStride: 4 * 4,
            attributes: attributes
        };
        const vertex = {
            buffers: [vertexLayout],
            module: module,
            entryPoint: "vsMain",
        };
        const target = {
            format: "bgra8unorm",
        };
        const fragment = {
            entryPoint: "fsMain",
            module,
            targets: [target],
        };
        const descriptor = {
            vertex,
            fragment
        };
        pipeline = gpu.createRenderPipeline(descriptor);
    }
    {
        let encoder = gpu.createCommandEncoder();
        const clearColor = { r: 0, g: 1, b: 1, a: 1 };
        const framebufferView = context.getCurrentTexture().createView();
        const colorAttachment = {
            view: framebufferView,
            loadValue: clearColor,
            storeOp: "store"
        };
        const descriptor = {
            colorAttachments: [colorAttachment]
        };
        let pass = encoder.beginRenderPass(descriptor);
        pass.setPipeline(pipeline);
        pass.setVertexBuffer(0, vertexBuffer, 0, vertexBufferSize);
        pass.draw(3, 1, 0, 0);
        pass.endPass();
        let cmds = encoder.finish();
        queue.submit([cmds]);
    }
});


/***/ }),

/***/ "./src/default.wgsl":
/*!**************************!*\
  !*** ./src/default.wgsl ***!
  \**************************/
/***/ ((module) => {

module.exports = "struct VertexIn {\r\n    [[location(0)]] position: vec4<f32>;\r\n};\r\n\r\nstruct VertexOut {\r\n    [[builtin(position)]] position: vec4<f32>;\r\n};\r\n\r\n[[stage(vertex)]]\r\nfn vsMain(input: VertexIn) -> VertexOut {\r\n    var result: VertexOut;\r\n    result.position = input.position;\r\n    return result;\r\n}\r\n\r\n[[stage(fragment)]]\r\nfn fsMain() -> [[location(0)]] vec4<f32> {\r\n    return vec4<f32>(0.4, 0.4, 0.8, 1.0);\r\n}\r\n";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main-bundle.min.js.map